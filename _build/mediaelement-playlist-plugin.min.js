'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* globals mejs, MediaElementPlayer */
(function () {
  function createElement(tagName, props) {
    var el = document.createElement(tagName);
    setNodeAttributes(el, props);
    return el;
  }

  function setNodeAttributes(target, props) {
    if (target.forEach) {
      return target.forEach(function (node) {
        setNodeAttributes(node, props);
      });
    }
    for (var key in props) {
      if (key.startsWith('style.')) {
        key = key.split('.')[0];
        target.style[key] = props[key];
      } else {
        target.setAttribute(key, props[key]);
      }
    }
  }

  var toggleDisplay = function toggleDisplay(el, shown) {
    var display = el.getAttribute('display') || 'block';
    var isShown = shown || display === 'none';
    if (isShown) {
      el.setAttribute('data-toggle-prev-display', display);
      el.style.display = 'none';
    } else {
      el.style.display = el.getAttribute('data-toggle-prev-display') || 'block';
    }
  };

  var toggleFade = function toggleFade(el, isShown) {
    if (window.GSAPTween) {
      return window.GSAPTween.to(el, { opacity: isShown ? 1 : 0 });
    }
    toggleDisplay(el, isShown);
  };

  Object.assign(mejs.MepDefaults, {
    loopText: mejs.i18n.t('Repeat On/Off'),
    shuffleText: mejs.i18n.t('Shuffle On/Off'),
    nextText: mejs.i18n.t('Next Track'),
    prevText: mejs.i18n.t('Previous Track'),
    playlistText: mejs.i18n.t('Show/Hide Playlist')
  });

  Object.assign(MediaElementPlayer.prototype, {
    // LOOP TOGGLE
    buildloop: function buildloop(player, controls, layers, media) {
      var t = this;
      var loop = createElement('div', {
        class: 'mejs__button mejs__loop ' + (player.options.loop ? 'mejs__loop-on' : 'mejs__loop-off')
      });
      loop.appendChild(createElement('button', {
        type: 'button',
        'aria-controls': player.id,
        title: player.options.loopText
      }));
      controls.appendChild(loop);
      loop.addEventListener('click', function () {
        player.options.loop = !player.options.loop;
        media.dispatchEvent(new Event('mep-looptoggle', [player.options.loop]));
        loop.classList.remove(player.options.loop ? 'mejs__loop-off' : 'mejs__loop-on');
        loop.classList.add(player.options.loop ? 'mejs__loop-on' : 'mejs__loop-off');
      });

      t.loopToggle = loop;
    },
    loopToggleClick: function loopToggleClick() {
      var t = this;
      t.loopToggle.dispatchEvent(new Event('click'));
    },

    // SHUFFLE TOGGLE
    buildshuffle: function buildshuffle(player, controls, layers, media) {
      var t = this;
      var shuffle = createElement('div', {
        class: 'mejs__button mejs__shuffle-button ' + (player.options.shuffle ? 'mejs__shuffle-on' : 'mejs__shuffle-off')
      });
      var shuffleButton = createElement('button', {
        type: 'button',
        'aria-controls': player.id,
        title: player.options.shuffleText
      });
      shuffle.appendChild(shuffleButton);
      controls.appendChild(shuffle);
      shuffle.addEventListener('click', function () {
        player.options.shuffle = !player.options.shuffle;
        media.dispatchEvent(new Event('mep-looptoggle', [player.options.loop]));
        shuffle.classList.remove(player.options.shuffle ? 'mejs__shuffle-off' : 'mejs__shuffle-on');
        shuffle.classList.add(player.options.shuffle ? 'mejs__shuffle-on' : 'mejs__shuffle-off');
      });

      t.shuffleToggle = shuffle;
    },
    shuffleToggleClick: function shuffleToggleClick() {
      var t = this;
      t.shuffleToggle.dispatchEvent(new Event('click'));
    },

    // PREVIOUS TRACK BUTTON
    buildprevtrack: function buildprevtrack(player, controls, layers, media) {
      var t = this;
      var prevtrack = createElement('div', {
        class: 'mejs__button mejs__prevtrack-button mejs__prevtrack'
      });
      var button = createElement('button', {
        type: 'button',
        'aria-controls': player.id,
        title: player.options.prevText
      });
      prevtrack.appendChild(button);
      controls.appendChild(prevtrack);
      prevtrack.addEventListener('click', function () {
        media.dispatchEvent(new Event('mep-playprevtrack'));
        player.playPrevTrack();
      });

      t.prevTrack = prevtrack;
    },
    prevTrackClick: function prevTrackClick() {
      var t = this;
      t.prevTrack.dispatchEvent(new Event('click'));
    },


    // NEXT TRACK BUTTON
    buildnexttrack: function buildnexttrack(player, controls, layers, media) {
      var t = this;
      var nexttrack = createElement('div', {
        class: 'mejs__button mejs__nexttrack-button mejs__nexttrack'
      });
      var button = createElement('button', {
        type: 'button',
        'aria-controls': player.id,
        title: player.options.nextText
      });
      nexttrack.appendChild(button);
      controls.appendChild(nexttrack);
      nexttrack.addEventListener('click', function () {
        media.dispatchEvent(new Event('mep-playnexttrack'));
        player.playNextTrack();
      });

      t.nextTrack = nexttrack;
    },
    nextTrackClick: function nextTrackClick() {
      var t = this;
      t.nextTrack.dispatchEvent(new Event('click'));
    },


    // PLAYLIST TOGGLE
    buildplaylist: function buildplaylist(player, controls, layers, media) {
      var t = this;
      var playlistToggle = createElement('div', {
        class: 'mejs__button mejs__playlist-button ' + (player.options.playlist ? 'mejs__hide-playlist' : 'mejs__show-playlist')
      });
      var button = createElement('button', {
        type: 'button',
        'aria-controls': player.id,
        title: player.options.playlistText
      });
      playlistToggle.appendChild(button);
      controls.appendChild(playlistToggle);
      playlistToggle.addEventListener('click', function () {
        t.togglePlaylistDisplay(player, layers, media);
      });

      t.playlistToggle = playlistToggle;
    },
    playlistToggleClick: function playlistToggleClick() {
      var t = this;
      t.playlistToggle.dispatchEvent(new Event('click'));
    },

    // PLAYLIST WINDOW
    buildplaylistfeature: function buildplaylistfeature(player, controls, layers, media) {
      var t = this;
      var playlist = createElement('div', { class: 'mejs__playlist mejs__layer' });
      var listUl = createElement('ul', { class: 'mejs' });
      playlist.appendChild(listUl);
      layers.appendChild(playlist);
      // activate playlist display when data-showplaylist is set
      if (media.getAttribute('data-showplaylist')) {
        player.options.playlist = true;
        // hide play overlay button
      }

      if (!player.options.playlist) {
        toggleDisplay(playlist, false);
      }

      var getTrackName = function getTrackName(trackUrl) {
        var trackUrlParts = trackUrl.split('/');
        if (trackUrlParts.length > 0) {
          return decodeURIComponent(trackUrlParts[trackUrlParts.length - 1]);
        } else {
          return '';
        }
      };

      // calculate tracks and build playlist
      var tracks = [];
      var sourceIsPlayable = void 0;
      var foundMatchingType = '';
      // $(media).children('source').each(function (index, element) { // doesn't work in Opera 12.12
      media.querySelectorAll('source').forEach(function (el) {
        // $('#' + player.id).find('.mejs__mediaelement source').each(function () {
        sourceIsPlayable = el.parentNode.canPlayType(el.type);
        if (!foundMatchingType && (sourceIsPlayable === 'maybe' || sourceIsPlayable === 'probably')) {
          foundMatchingType = el.getAttribute('type');
        }
        if (!!foundMatchingType && el.getAttribute('type') === foundMatchingType) {
          if (el.src.trim() !== '') {
            var track = {};
            track.source = el.src.trim();
            var titleTrim = el.getAttribute('title').trim();
            if (titleTrim !== '') {
              track.name = titleTrim;
            } else {
              track.name = getTrackName(track.source);
            }
            // add poster image URL from data-poster attribute
            track.poster = el.getAttribute('data-poster');
            tracks.push(track);
          }
        }
      });
      tracks.forEach(function (track) {
        var thisLi = createElement('li', {
          'data-url': track.source,
          'data-poster': track.poster,
          title: track.name,
          'style.background-image': player.media.classList.contains('mep-slider') ? 'url("' + track.poster + ')"' : 'inherit'
        });
        var trackSpan = createElement('span', {});
        trackSpan.innerHTML = track.name;
        thisLi.appendChild(trackSpan);
        listUl.appendChild(thisLi);
      });
      /* slider */
      player.videoSliderTracks = tracks.length;

      // set the first track as current
      var firstItem = listUl.children[0];
      firstItem.classList.add('played');
      firstItem.classList.add('current');
      // set initial poster image - only for audio playlists
      if (player.media.matches('audio')) {
        player.changePoster(firstItem.getAttribute('data-poster'));
      }
      /* slider */
      var prevVid = createElement('a', { class: 'mep-prev' });
      var nextVid = createElement('a', { class: 'mep-prev' });

      player.videoSliderIndex = 0;

      playlist.appendChild(prevVid);
      playlist.appendChild(nextVid);
      // setNodeAttributes(
      //   listUl.querySelectorAll('li'),
      //   {'style.transform': 'translate3d(0, -20px, 0) scale3d(0.75, 0.75, 1)'}
      // )
      toggleDisplay(prevVid, false);

      var previousNextHandler = function previousNextHandler() {
        var moveMe = true;

        player.videoSliderIndex -= 1;
        if (player.videoSliderIndex < 0) {
          player.videoSliderIndex = 0;
          moveMe = false;
        }

        toggleFade(nextVid, player.videoSliderIndex !== player.videoSliderTracks - 1);
        toggleFade(prevVid, player.videoSliderIndex !== 0);

        if (moveMe === true) {
          player.sliderWidth = parseInt(getComputedStyle(document.getElementById(player.id)).width);
          setNodeAttributes(listUl.querySelectorAll('li'), {
            transform: 'translate3d(-' + Math.ceil(player.sliderWidth * player.videoSliderIndex) + 'px, -20px, 0) scale3d(0.75, 0.75, 1))'
          });
        }
      };
      prevVid.addEventListener('click', previousNextHandler); // initially hide prevVid button
      nextVid.addEventListener('click', previousNextHandler);

      // play track from playlist when clicking it
      layers.querySelectorAll('.mejs__playlist > ul li').forEach(function (el) {
        el.addEventListener('click', function () {
          // pause current track or play other one
          if (!this.classList.contains('current')) {
            // clicked other track - play it
            this.classList.add('played');
            player.playTrack(this);
          } else {
            // clicked current track - play if paused and vice versa
            if (!player.media.paused) {
              // pause if playing
              player.pause();
            } else {
              // play if paused
              player.play();
            }
          }
        });
      });

      // when current track ends - play the next one
      media.addEventListener('ended', function () {
        player.playNextTrack();
      }, false);

      // set play and paused class to container
      media.addEventListener('playing', function () {
        player.container.classList.remove('mep-paused');
        player.container.classList.add('mep-playing');

        // hide playlist for videos
        if (media.matches('video')) {
          t.togglePlaylistDisplay(player, layers, media, 'hide');
        }
      }, false);

      /* mediaelement.js hides poster on "play" for all player types - not so great for audio */
      media.addEventListener('play', function () {
        if (player.media.matches('audio')) {
          layers.find('.mejs__poster').show();
        }
      }, false);

      media.addEventListener('pause', function () {
        player.container.classList.remove('mep-playing');
        player.container.classList.add('mep-paused');
      }, false);
    },
    playNextTrack: function playNextTrack() {
      var t = this;
      var nxt = void 0;
      var tracks = t.layers.querySelectorAll('.mejs__playlist > ul > li');
      var current = t.layers.querySelector('.mejs__playlist > ul > li.current');
      var notplayed = [].concat(_toConsumableArray(tracks)).filter(function (el) {
        return !el.classList.contains('played');
      });

      if (notplayed.length < 1) {
        tracks.forEach(function (el) {
          el.classList.remove('played');
        });
        notplayed = [].concat(_toConsumableArray(tracks)).filter(function (el) {
          return !el.classList.contains('current');
        });
      }
      if (t.options.shuffle) {
        var random = Math.floor(Math.random() * notplayed.length);
        nxt = notplayed[random];
      } else {
        nxt = current.nextElementSibling;
        if (nxt.length === null && t.options.loop) {
          nxt = tracks[0];
        }
      }
      if (nxt) {
        nxt.classList.add('played');
        t.playTrack(nxt);
      }
    },
    playPrevTrack: function playPrevTrack() {
      var t = this;
      var prev = void 0;
      var tracks = t.layers.querySelectorAll('.mejs__playlist > ul > li');
      var current = t.layers.querySelector('.mejs__playlist > ul > li.current');
      var played = [].concat(_toConsumableArray(tracks)).filter(function (el) {
        return el.classList.contains('played') && !el.classList.contains('current');
      });
      if (played.length < 1) {
        current.classList.remove('played');
        played = [].concat(_toConsumableArray(tracks)).filter(function (el) {
          return !el.classList.contains('current');
        });
      }
      if (t.options.shuffle) {
        var random = Math.floor(Math.random() * played.length);
        prev = played[random];
      } else {
        prev = current.previousElementSibling;
        if (!prev && t.options.loop) {
          prev = tracks[tracks.length - 1];
        }
      }
      if (prev) {
        current.classList.remove('played');
        t.playTrack(prev);
      }
    },
    changePoster: function changePoster(posterUrl) {
      var t = this;
      setNodeAttributes(t.layers.querySelector('.mejs__playlist'), {
        'background-image': 'url("' + posterUrl + '")'
      });
      // also set actual poster
      t.setPoster(posterUrl);
      // make sure poster is visible (not the case if no poster attribute was set)
      toggleDisplay(t.layers.querySelector('.mejs__poster'), true);
    },
    playTrack: function playTrack(track) {
      var t = this;
      t.pause();
      t.setSrc(track.getAttribute('data-url'));
      t.load();
      t.changePoster(track.getAttribute('data-poster'));
      t.play();
      var tracks = t.layers.querySelectorAll('.mejs__playlist > ul > li');
      tracks.forEach(function (el) {
        el.classList[el === track ? 'add' : 'remove']('current');
      });
    },
    playTrackURL: function playTrackURL(url) {
      var t = this;
      var tracks = t.layers.querySelectorAll('.mejs__playlist > ul > li');
      var track = tracks.querySelector('[data-url="' + url + '"]');
      t.playTrack(track);
    },
    togglePlaylistDisplay: function togglePlaylistDisplay(player, layers, media, showHide) {
      var t = this;
      if (showHide) {
        player.options.playlist = showHide === 'show';
      } else {
        player.options.playlist = !player.options.playlist;
      }
      media.dispatchEvent(new Event('mep-playlisttoggle', [player.options.playlist]));
      // toggle playlist display
      var isP = player.options.playlist;
      toggleFade(layers.querySelector('.mejs__playlist'), isP);
      t.playlistToggle.classList.add(isP ? 'mejs__hide-playlist' : 'mejs__show-playlist');
      t.playlistToggle.classList.remove(isP ? 'mejs__show-playlist' : 'mejs__hide-playlist');
    }
  });
})();
//# sourceMappingURL=mediaelement-playlist-plugin.min.js.map
